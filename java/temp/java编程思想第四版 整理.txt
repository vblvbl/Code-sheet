1.1抽象过程
	所有编程语言都提供抽象机制。可以认为，人们所能够解决问题的问题的复杂性直接取决于抽象的类型和质量。
	程序可以通过添加新类型的对象使自身适用于某个特定问题。因此，当你在阅读描述解决方案的代码的同时，也是在阅读问题的表述。oop允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。但是它仍然与计算机有联系：每个对象看起来都有点像一台微型计算机，它具有状态，还具有操作，用户可以要求对象执行这些操作。如果要对现实世界中的对象做类比，那么说他们都具有特性和行为似乎不错。
	Alan Kay 总结了第一个成功的面向对象语言，同时也是java所基于的语言之一的smalltalk的五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：
	1.万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件（狗，建筑物，服务等），将其表示为程序中的对象。
	2.程序是对象的集合，它们通过发送消息来告知彼此所要做的。想要请求一个对象，就必须对该对象发送一条消息。更具体地说，他可以把消息想象为对摸个特定对象的方法的调用请求。
	3每个对象都有自己的由其他对象所构成的存储。换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。
	4每个对象都拥有其他类型。按照通用的说法，“每个对象都是某个类的一个实例（instance）”，这里类就是类型的同义词。每个类最重要的区别于其他类的特性就是“可以发送什么样的消息给它”。
	5某一特定类型的所有对象都可以接受同样的消息。这是一句意味深长的表述。“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理所有与几何形性质相关的事物的代码。这种可替代性（substitutability）是oop中最强有力的概念之一。
	对象具有状态，行为和标识。这意味着每一个对象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地与其他对象区分开来，具体说来，就是每一个对象在内存中都有一个唯一的地址。
1.2 每个对象都有一个接口
	实体就是对象，每一个对象都属于定义了特性和行为的某个特定的类。
	尽管我们在面向对象程序设计中实际上进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用class这个关键词来表示数据类型。当看到类型一词时，可将其作为类来考虑，反之亦然。
	因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型，例如所有浮点型数字具有相同的特性和行为集合。二者的差异在于，程序员通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。可以根据需求，通过添加新的数据类型来扩展编程语言。编程系统欣然接受新的类，并且像对待内置类型一样地照管它们和进行类型检查。
	一旦类被建立，就可以随心所欲地创建类的任意个对象，然后去操作它们，就像它们是存在于你的待求解问题中的元素一样。事实上，面向对象程序设计的挑战之一，就是在问题空间的元素和解空间的对象之间创建一对一的映射。
	怎样才能获得有用的对象呢？必须有某种方式产生对象的请求，使对象完成各种任务。每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。
	 light lt= new light();
	lt.on();
	代码解释：创建一个对象的引用lt，然后调用new方法来创建该类型的新对象。为了向对象发送消息，需要声明对象的名称，并以圆点符号链接一个消息请求。

	接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码。这些代码与隐藏的数据一起构成了实现。从过程型编程的观点来看，这并不太复杂。在类型中，每一个可能的请求都有一个方法与之相关联，当向对象发送请求时，与之相关联的方法就会被调用。此过程通常被概括为：向某个对象“发送消息”（产生请求），这个对象便知道此消息的目的，然后执行对应的程序代码。
	uml（unified modelling language,统一建模语言），每个类都用一个方框表示，类名在方框的顶部，你所关心的任何数据成员都描述在方框的中间部分，方法（隶属于此对象的，用来接受你发给此对象的消息的函数）在方框的底部。通常，只有类名和公共方法被示与uml设计图中，因此，方框的中部就像本列一样并未给出。如果只对类型感兴趣，那么方框的底部甚至也不需要给出
1.3每个对象都提供服务
	将对象看作是服务提供者还有一个附带的好处：它有助于提高对象的内聚性。高内聚是软件设计的基本质量要求之一：这意味着一个软件构件（列如一个对象，当然它也有可能是指一个方法或一个对象库）的各个方面“组合”得很好。人们在设计对象时所面临的一个问题是，将过多的功能都塞在一个对象中。列如，在检查打印模式的模块中，你可以这样设计一个对象，让它了解所有的格式和打印技术。你可能会发现，这些功能对于一个对象来说太多了，你需要的是三个甚至更多个对象，其中，一个对象可以是所有可能的支票排版的目录，它可以被用来查询有关如何打印一张支票的信息；另一个对象（或对象集合）可以是一个通用的打印接口，它知道有关所有不同类型的打印机的信息（但是不包含任何有关簿记的内容，它更应该是一个需要购买而不是自己编写的对象）；第三个对象通过调用另外两个对象的服务来完成打印任务。这样每个对象都有一个它所能提供服务的内聚的集合。在良好的面向对象设计中，每个对象都可以很好地完成一项任务，但是它并不试图做更多的事。就像在这里看到的，不仅允许通过购买获得某些对象（打印机接口对象），而且还可以创建能够在别处复用的新对象（支票排版目录对象）。
	1.4被隐藏的具体实现